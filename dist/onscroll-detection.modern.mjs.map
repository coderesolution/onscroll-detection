{"version":3,"file":"onscroll-detection.modern.mjs","sources":["../src/index.js"],"sourcesContent":["/**\n * Written by Elliott Mangham at Code Resolution.\n * Maintained by Code Resolution.\n * made@coderesolution.com\n */\nexport default class OnscrollDetection {\n\tconstructor(options = {}, gsap = null, ScrollTrigger = null) {\n\t\t// Set dependencies\n\t\tthis._gsap = gsap\n\t\tthis._ScrollTrigger = ScrollTrigger\n\n\t\t// Initialise class properties with default values or provided options\n\t\tthis.elements = options.elements || '[data-onscroll]'\n\t\tthis.screen = options.screen || '(min-width: 1025px)'\n\t\tthis.triggers = new Map()\n\t\tthis.debug = options.debug || false\n\n\t\t// Set class names to defaults or provided options\n\t\tthis.scrollingClass = options.scrollingClass || 'is-scrolling'\n\t\tthis.scrolledClass = options.scrolledClass || 'has-scrolled'\n\t\tthis.stickyClass = options.stickyClass || 'is-sticky'\n\t\tthis.stuckClass = options.stuckClass || 'has-stuck'\n\n\t\t// Initialise event handlers\n\t\tthis.eventHandlers = {}\n\n\t\t// Set autoStart to true by default, or use provided value\n\t\tthis.autoStart = options.autoStart !== undefined ? options.autoStart : true\n\n\t\t// Initialise the class\n\t\tif (this.autoStart) {\n\t\t\tthis.init()\n\t\t}\n\t}\n\n\t// Register GSAP and plugins\n\tregister(gsap, ScrollTrigger) {\n\t\tthis._gsap = gsap\n\t\tthis._ScrollTrigger = ScrollTrigger\n\t}\n\n\t// Initialisation function\n\tinit() {\n\t\t// Check if gsap is registered\n\t\tif (this._gsap === null || this._gsap === undefined) {\n\t\t\tconsole.log('GSAP is not registered. Exiting')\n\t\t\treturn\n\t\t}\n\n\t\t// Check if ScrollTrigger is registered\n\t\tif (this._ScrollTrigger === null || this._ScrollTrigger === undefined) {\n\t\t\tconsole.log('ScrollTrigger is not registered. Exiting')\n\t\t\treturn\n\t\t}\n\n\t\ttry {\n\t\t\t// Convert elements to an array and loop through each\n\t\t\tthis._gsap.utils.toArray(this.elements).forEach((element, index) => {\n\t\t\t\t// Get the trigger element\n\t\t\t\tconst trigger = this.getTrigger(element)\n\n\t\t\t\t// Get the screen media query\n\t\t\t\tconst screen = this.getScreen(element)\n\n\t\t\t\t// Create a matchMedia instance\n\t\t\t\tconst matchMedia = this._gsap.matchMedia()\n\n\t\t\t\t// Get the animation properties for 'from' state\n\t\t\t\tconst fromProperties = this.getFromProperties(element)\n\n\t\t\t\tfromProperties.startAt = { backgroundColor: 'red' }\n\t\t\t\tfromProperties.immediateRender = true\n\n\t\t\t\t// Get the animation properties for 'to' state\n\t\t\t\tconst toProperties = this.getToProperties(element, index, trigger)\n\n\t\t\t\t// Add the animation to the matchMedia instance and store the ScrollTrigger instance\n\t\t\t\tmatchMedia.add(screen, () => {\n\t\t\t\t\tconst gsapAnimation = this._gsap.fromTo(element, fromProperties, toProperties)\n\n\t\t\t\t\tthis.triggers.set(gsapAnimation.scrollTrigger, {\n\t\t\t\t\t\telement,\n\t\t\t\t\t\tfromProperties,\n\t\t\t\t\t\ttoProperties,\n\t\t\t\t\t\tgsapAnimation,\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\t// Enable debug mode for logging\n\t\t\t\tthis.debugMode(element, index)\n\t\t\t})\n\t\t} catch (error) {\n\t\t\t// Catch and log any errors\n\t\t\tconsole.error('Error initialising OnscrollDetection:', error)\n\t\t}\n\t}\n\n\t// Function to load and initialize the class\n\tstart() {\n\t\t// Initialize the class\n\t\tthis.init()\n\t}\n\n\t// Events\n\ton(event, handler) {\n\t\tif (!this.eventHandlers[event]) {\n\t\t\tthis.eventHandlers[event] = []\n\t\t}\n\t\tthis.eventHandlers[event].push(handler)\n\t}\n\n\temit(event, ...args) {\n\t\tif (this.eventHandlers[event]) {\n\t\t\tthis.eventHandlers[event].forEach((handler) => handler(...args))\n\t\t}\n\t}\n\n\t// Get the trigger element for ScrollTrigger\n\tgetTrigger(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto']) && !element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-auto is present and data-onscroll-trigger is not, use the parent element as the trigger\n\t\t\treturn element.parentElement\n\t\t} else if (element.hasAttribute('data-onscroll-trigger')) {\n\t\t\t// If data-onscroll-trigger is present, try to find the DOM element specified by the attribute\n\t\t\tlet triggerElement = document.querySelector(element.dataset.onscrollTrigger)\n\t\t\tif (triggerElement) {\n\t\t\t\treturn triggerElement\n\t\t\t} else {\n\t\t\t\tconsole.error(\n\t\t\t\t\t`Element specified by data-onscroll-trigger not found: ${element.dataset.onscrollTrigger}`\n\t\t\t\t)\n\t\t\t\treturn element\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, use the element itself as the trigger\n\t\t\treturn element\n\t\t}\n\t}\n\n\t// Get the screen media query\n\tgetScreen(element) {\n\t\treturn element.hasAttribute('data-onscroll-screen') ? element.dataset.onscrollScreen : this.screen\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetFromProperties(element) {\n\t\tconst animateFrom = this.getAnimateFrom(element)\n\t\tconst { offset } = this.getOffsetAndDistance(element)\n\n\t\treturn {\n\t\t\t...animateFrom,\n\t\t\tbottom: this.hasAttributes(element, ['data-onscroll-auto', 'data-onscroll-reverse']) ? 'auto' : null,\n\t\t\ttop:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-auto']) &&\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-reverse'])\n\t\t\t\t\t? 'auto'\n\t\t\t\t\t: null,\n\t\t\tx:\n\t\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t\ty:\n\t\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t\t\t\t? offset\n\t\t\t\t\t: null,\n\t\t}\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetToProperties(element, index, trigger) {\n\t\tconst animateTo = this.getAnimateTo(element)\n\t\tconst stickyProperties = this.getStickyProperties(element)\n\t\tconst isSticky = this.hasAttributes(element, ['data-onscroll-sticky'])\n\t\tconst customEventName = element.getAttribute('data-onscroll-call')\n\t\tconst progressEventName = element.getAttribute('data-onscroll-progress')\n\n\t\t// Helper function to dispatch the custom event\n\t\tconst dispatchCustomEvent = (when, direction) => {\n\t\t\tif (customEventName) {\n\t\t\t\twindow.dispatchEvent(\n\t\t\t\t\tnew CustomEvent(customEventName, {\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\ttarget: element,\n\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up',\n\t\t\t\t\t\t\twhen,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\t// Helper function to dispatch progress event\n\t\tconst dispatchProgressEvent = (progress, direction) => {\n\t\t\tif (progressEventName) {\n\t\t\t\twindow.dispatchEvent(\n\t\t\t\t\tnew CustomEvent(progressEventName, {\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\telement: element,\n\t\t\t\t\t\t\tprogress: progress,\n\t\t\t\t\t\t\tdirection: direction === 1 ? 'down' : 'up',\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\t...animateTo,\n\t\t\tx: this.getX(element),\n\t\t\ty: this.getY(element),\n\t\t\tease: 'none',\n\t\t\tscrollTrigger: {\n\t\t\t\ttrigger: isSticky ? element : trigger,\n\t\t\t\tstart: this.getStart(element),\n\t\t\t\tend: this.getEnd(element),\n\t\t\t\tinvalidateOnRefresh: true,\n\t\t\t\tpin: stickyProperties.pin,\n\t\t\t\tpinSpacing: stickyProperties.pinSpacing,\n\t\t\t\tscrub: this.getScrub(element),\n\t\t\t\tmarkers: this.hasAttributes(element, ['data-onscroll-debug']),\n\t\t\t\tonUpdate: (self) => {\n\t\t\t\t\tlet progress = self.progress.toFixed(2)\n\t\t\t\t\telement.style.setProperty('--onscrollProgress', progress)\n\n\t\t\t\t\tif (progressEventName) {\n\t\t\t\t\t\tdispatchProgressEvent(progress, self.direction)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonToggle: (self) => {\n\t\t\t\t\tif (!self.isActive) {\n\t\t\t\t\t\telement.style.setProperty('--onscrollProgress', 0)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tonEnter: ({ direction }) => {\n\t\t\t\t\telement.classList.add(this.scrollingClass, this.scrolledClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.add(this.stickyClass, this.stuckClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onEnter', direction)\n\t\t\t\t\tthis.emit('onEnter', element)\n\t\t\t\t},\n\t\t\t\tonLeave: ({ direction }) => {\n\t\t\t\t\telement.classList.remove(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.remove(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onLeave', direction)\n\t\t\t\t\tthis.emit('onLeave', element)\n\t\t\t\t},\n\t\t\t\tonEnterBack: ({ direction }) => {\n\t\t\t\t\telement.classList.add(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.add(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onEnterBack', direction)\n\t\t\t\t\tthis.emit('onEnterBack', element)\n\t\t\t\t},\n\t\t\t\tonLeaveBack: ({ direction }) => {\n\t\t\t\t\telement.classList.remove(this.scrollingClass)\n\t\t\t\t\tif (isSticky) {\n\t\t\t\t\t\telement.classList.remove(this.stickyClass)\n\t\t\t\t\t}\n\t\t\t\t\tdispatchCustomEvent('onLeaveBack', direction)\n\t\t\t\t\tthis.emit('onLeaveBack', element)\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\t// Get the sticky properties for ScrollTrigger animation\n\tgetStickyProperties(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn { pin: true, pinSpacing: false }\n\t\t} else {\n\t\t\treturn { pin: false, pinSpacing: true }\n\t\t}\n\t}\n\n\t// Check if an element has all the specified attributes\n\thasAttributes(element, attrs) {\n\t\treturn attrs.every((attr) => element.hasAttribute(attr))\n\t}\n\n\t// Get the animation properties for 'from' state\n\tgetAnimateFrom(element) {\n\t\treturn element.hasAttribute('data-onscroll-from') ? JSON.parse(element.dataset.onscrollFrom) : []\n\t}\n\n\t// Get the animation properties for 'to' state\n\tgetAnimateTo(element) {\n\t\treturn element.hasAttribute('data-onscroll-to') ? JSON.parse(element.dataset.onscrollTo) : []\n\t}\n\n\t// Get the offset value\n\tgetOffset(element) {\n\t\treturn element.hasAttribute('data-onscroll-offset') ? parseInt(element.dataset.onscrollOffset) : null\n\t}\n\n\t// Get the scroll direction\n\tgetDirection(element) {\n\t\treturn element.dataset.onscrollDirection ? element.dataset.onscrollDirection : 'y'\n\t}\n\n\t// Get the 'x' value for ScrollTrigger animation\n\tgetX(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn null\n\t\t}\n\t\tif (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t(this.getDirection(element) === 'x' || this.getDirection(element) === 'xy')\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the 'y' value for ScrollTrigger animation\n\tgetY(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn null\n\t\t}\n\t\tif (\n\t\t\t!this.hasAttributes(element, ['data-onscroll-direction']) ||\n\t\t\t(this.hasAttributes(element, ['data-onscroll-direction']) &&\n\t\t\t\t(this.getDirection(element) === 'y' || this.getDirection(element) === 'xy'))\n\t\t) {\n\t\t\treturn this.getDistanceOrSpeed(element)\n\t\t}\n\t}\n\n\t// Get the offset and distance values\n\tgetOffsetAndDistance(element) {\n\t\t// Check if the element has the data-onscroll-sticky attribute\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\treturn { offset: null, distance: null }\n\t\t}\n\n\t\tlet offset = null\n\t\tlet distance = null\n\t\tconst triggerElement = this.getTrigger(element)\n\t\tconst triggerHeight = triggerElement.offsetHeight\n\n\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\tconst [offsetValue, distanceValue] = element.dataset.onscrollOffset.split(',')\n\n\t\t\t// If the offset value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (offsetValue.trim().endsWith('%')) {\n\t\t\t\tconst offsetPercentage = parseFloat(offsetValue) / 100\n\t\t\t\toffset = offsetPercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\toffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\t// If the distance value ends with a '%', calculate it as a percentage of the trigger height\n\t\t\tif (distanceValue.trim().endsWith('%')) {\n\t\t\t\tconst distancePercentage = parseFloat(distanceValue) / 100\n\t\t\t\tdistance = distancePercentage * triggerHeight\n\t\t\t} else {\n\t\t\t\tdistance = parseFloat(distanceValue)\n\t\t\t}\n\t\t}\n\n\t\treturn { offset, distance }\n\t}\n\n\t// Get the distance or speed value for ScrollTrigger animation\n\tgetDistanceOrSpeed(element) {\n\t\tconst { distance } = this.getOffsetAndDistance(element)\n\t\tconst viewportHeight = window.innerHeight\n\t\tlet scrollSpeed = element.dataset.onscrollSpeed\n\t\tlet additionalDistance = 0\n\n\t\t// Check if there are two values\n\t\tif (scrollSpeed && scrollSpeed.includes(',')) {\n\t\t\tconst [speed, percentage] = scrollSpeed.split(',').map(parseFloat)\n\n\t\t\t// Update the scrollSpeed and calculate the additional distance\n\t\t\tscrollSpeed = speed\n\t\t\tadditionalDistance = (percentage / 100) * viewportHeight\n\n\t\t\t// If scrollSpeed is negative, subtract the additional distance\n\t\t\tif (scrollSpeed < 0) {\n\t\t\t\tadditionalDistance *= -1\n\t\t\t}\n\t\t} else {\n\t\t\tscrollSpeed = parseFloat(scrollSpeed || '0')\n\t\t}\n\n\t\tif (this.hasAttributes(element, ['data-onscroll-auto'])) {\n\t\t\tconst triggerElement = this.getTrigger(element)\n\t\t\tconst autoDistance = Math.abs(triggerElement.offsetHeight - element.offsetHeight)\n\t\t\treturn this.hasAttributes(element, ['data-onscroll-reverse']) ? -autoDistance : autoDistance\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\tconst elementHeight = element.offsetHeight\n\t\t\tconst scrollDistance = scrollSpeed * elementHeight + additionalDistance\n\t\t\treturn scrollDistance\n\t\t} else if (distance !== null) {\n\t\t\treturn distance\n\t\t}\n\t}\n\n\t// Get the delay value which controls the scrub setting\n\tgetScrub(element) {\n\t\tif (this.hasAttributes(element, ['data-onscroll-delay'])) {\n\t\t\treturn parseInt(element.dataset.onscrollDelay)\n\t\t} else {\n\t\t\treturn true // Default scrub value if no 'data-onscroll-delay' attribute is present\n\t\t}\n\t}\n\n\t// Get the start value for ScrollTrigger animation\n\tgetStart(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\tlet stickyOffset = 0\n\n\t\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\t\tconst [offsetValue] = element.dataset.onscrollOffset.split(',')\n\t\t\t\tstickyOffset = parseFloat(offsetValue)\n\t\t\t}\n\n\t\t\treturn (element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top top') + '+=' + stickyOffset\n\t\t} else if (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-preset', 'data-onscroll-offset']) &&\n\t\t\tthis.getDirection(element) !== 'x' &&\n\t\t\t!this.hasAttributes(element, ['data-onscroll-start', 'data-onscroll-sticky'])\n\t\t) {\n\t\t\tconst [offsetValue] = element.dataset.onscrollOffset.split(',')\n\t\t\tlet positionElement = parseFloat(offsetValue) < 0 ? 'top+=' + offsetValue : 'top+=0'\n\t\t\tlet positionMarker = 'bottom'\n\n\t\t\treturn positionElement + ' ' + positionMarker\n\t\t} else {\n\t\t\treturn element.dataset.onscrollStart ? element.dataset.onscrollStart : 'top bottom'\n\t\t}\n\t}\n\n\t// Get the end value for ScrollTrigger animation\n\tgetEnd(element) {\n\t\tif (element.hasAttribute('data-onscroll-sticky')) {\n\t\t\tconst trigger = this.getTrigger(element)\n\t\t\tlet stickyOffset = 0\n\n\t\t\tif (element.hasAttribute('data-onscroll-offset')) {\n\t\t\t\tconst [, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\t\tstickyOffset = parseFloat(distanceValue)\n\t\t\t}\n\n\t\t\tconst stickyDistance = trigger.clientHeight - element.clientHeight - stickyOffset\n\n\t\t\treturn element.dataset.onscrollEnd ? element.dataset.onscrollEnd : '+=' + stickyDistance\n\t\t} else if (this.hasAttributes(element, ['data-onscroll-speed']) && !element.hasAttribute('data-onscroll-end')) {\n\t\t\tconst scrollDistance = this.getDistanceOrSpeed(element)\n\n\t\t\treturn `bottom${scrollDistance >= 0 ? '+=' : '-='}${Math.abs(scrollDistance)} top`\n\t\t} else if (\n\t\t\tthis.hasAttributes(element, ['data-onscroll-preset', 'data-onscroll-offset']) &&\n\t\t\tthis.getDirection(element) !== 'x' &&\n\t\t\t!this.hasAttributes(element, ['data-onscroll-end', 'data-onscroll-sticky'])\n\t\t) {\n\t\t\tconst [, distanceValue] = element.dataset.onscrollOffset.split(',')\n\t\t\tlet positionElement = 'bottom+=' + distanceValue\n\t\t\tlet positionMarker = 'top'\n\n\t\t\treturn positionElement + ' ' + positionMarker\n\t\t} else {\n\t\t\treturn element.dataset.onscrollEnd ? element.dataset.onscrollEnd : 'bottom top'\n\t\t}\n\t}\n\n\t// Enable debug mode for logging\n\tdebugMode(element, index) {\n\t\tif (!this.debug && !this.hasAttributes(element, ['data-onscroll-debug'])) return\n\n\t\tconst { offset /*, distance*/ } = this.getOffsetAndDistance(element)\n\t\tlet speedMultiplier = 0\n\t\tlet speedViewportPercentage = 0\n\n\t\tif (this.hasAttributes(element, ['data-onscroll-speed'])) {\n\t\t\tconst speedValues = element.dataset.onscrollSpeed.split(',')\n\n\t\t\tspeedMultiplier = parseFloat(speedValues[0])\n\t\t\tspeedViewportPercentage = parseFloat(speedValues[1])\n\n\t\t\t// Provide defaults in case parsing failed\n\t\t\tspeedMultiplier = isNaN(speedMultiplier) ? 0 : speedMultiplier\n\t\t\tspeedViewportPercentage = isNaN(speedViewportPercentage) ? 0 : speedViewportPercentage\n\t\t}\n\n\t\tconst attrs = element.dataset\n\t\tconst hasSpeed = this.hasAttributes(element, ['data-onscroll-speed'])\n\t\tconst hasPreset = this.hasAttributes(element, ['data-onscroll-preset'])\n\t\tconst hasSticky = this.hasAttributes(element, ['data-onscroll-sticky'])\n\t\tconst hasReverse = this.hasAttributes(element, ['data-onscroll-reverse'])\n\n\t\tconsole.group(`OnscrollDetection() debug instance (#${index + 1})`)\n\t\tconsole.log({\n\t\t\telement: element,\n\t\t\ttrigger: this.getTrigger(element),\n\t\t\ttriggerStart: this.getStart(element),\n\t\t\ttriggerEnd: this.getEnd(element),\n\t\t\tauto: this.hasAttributes(element, ['data-onscroll-auto']),\n\t\t\toffsetBefore: offset,\n\t\t\toffsetAfter: this.getDistanceOrSpeed(element),\n\t\t\tdelay: this.getScrub(element),\n\t\t\tscreen: this.getScreen(element),\n\t\t\tspeed: hasSpeed\n\t\t\t\t? `${parseFloat(\n\t\t\t\t\t\tspeedMultiplier * element.clientHeight + (speedViewportPercentage / 100) * window.innerHeight\n\t\t\t\t  )} (${parseFloat(speedMultiplier)}x element height + ${parseFloat(\n\t\t\t\t\t\tspeedViewportPercentage\n\t\t\t\t  )}% of the viewport height)`\n\t\t\t\t: null,\n\t\t\tdirection: this.hasAttributes(element, ['data-onscroll-direction']) ? attrs.onscrollDirection : 'y',\n\t\t\tpreset: hasPreset,\n\t\t\treverse: hasReverse,\n\t\t\tsticky: hasSticky,\n\t\t\tanimateFrom: this.getAnimateFrom(element),\n\t\t\tanimateTo: this.getAnimateTo(element),\n\t\t\tcustomEvent: this.hasAttributes(element, ['data-onscroll-call']) ? attrs.onscrollCall : null,\n\t\t})\n\n\t\tconst warnings = [\n\t\t\t{\n\t\t\t\tcondition: this.hasAttributes(element, ['data-onscroll-offset']) && hasSpeed,\n\t\t\t\tmessage: '`offset` and `speed` should not be used together',\n\t\t\t},\n\t\t\t{\n\t\t\t\tcondition:\n\t\t\t\t\thasPreset &&\n\t\t\t\t\t(this.hasAttributes(element, ['data-onscroll-start']) ||\n\t\t\t\t\t\tthis.hasAttributes(element, ['data-onscroll-end'])),\n\t\t\t\tmessage: '`preset` should not be used in conjunction with `start` or `end` settings',\n\t\t\t},\n\t\t\t{ condition: hasSticky && hasSpeed, message: '`sticky` should not be used in conjunction with `speed`' },\n\t\t\t{\n\t\t\t\tcondition:\n\t\t\t\t\thasSticky &&\n\t\t\t\t\tthis.hasAttributes(element, ['data-onscroll-offset']) &&\n\t\t\t\t\tthis.hasAttributes(element, ['data-onscroll-end']),\n\t\t\t\tmessage: 'Your bottom `offset` will be ignored due to custom `end` on the `sticky` element',\n\t\t\t},\n\t\t\t{\n\t\t\t\tcondition:\n\t\t\t\t\thasReverse &&\n\t\t\t\t\t(!this.hasAttributes(element, ['data-onscroll-auto']) ||\n\t\t\t\t\t\tthis.hasAttributes(element, ['data-onscroll-offset']) ||\n\t\t\t\t\t\thasSticky ||\n\t\t\t\t\t\thasSpeed),\n\t\t\t\tmessage:\n\t\t\t\t\t'`reverse` is not compatible with `offset`, `speed` or `sticky` and should only be used in conjunction with `auto`',\n\t\t\t},\n\t\t\t{ condition: hasSpeed && hasPreset, message: '`preset` has no effect in conjunction with `speed` setting' },\n\t\t\t{\n\t\t\t\tcondition: this.getDirection(element) === 'x' && hasPreset,\n\t\t\t\tmessage: '`preset` has no effect in conjunction with `x` direction',\n\t\t\t},\n\t\t]\n\n\t\twarnings.forEach((warning) => warning.condition && console.warn(warning.message))\n\t\tconsole.groupEnd()\n\t}\n\n\t// Fetch a trigger\n\tfetch(elementOrIndex) {\n\t\tif (typeof elementOrIndex === 'number') {\n\t\t\t// Treat argument as an index\n\t\t\tconst keys = Array.from(this.triggers.keys())\n\t\t\treturn keys[elementOrIndex]\n\t\t} else {\n\t\t\t// Assume argument is a DOM element\n\t\t\tlet trigger = null\n\t\t\tthis.triggers.forEach((value, key) => {\n\t\t\t\tif (value.element === elementOrIndex) {\n\t\t\t\t\ttrigger = key\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn trigger\n\t\t}\n\t}\n\n\t// Refresh ScrollTrigger instances\n\trefresh() {\n\t\tthis._ScrollTrigger.refresh()\n\n\t\t// Emit event after refresh is done\n\t\tthis.emit('refresh')\n\t}\n\n\t// Restart the animations and reinitialize the ScrollTrigger instances\n\trestart() {\n\t\t// Stop the current animations and remove ScrollTriggers\n\t\tthis.stop()\n\n\t\t// Kill all existing ScrollTrigger instances\n\t\tthis._ScrollTrigger.getAll().forEach((trigger) => trigger.kill())\n\n\t\t// Refresh ScrollTrigger\n\t\tthis._ScrollTrigger.refresh()\n\n\t\t// Reapply animations and initialize ScrollTrigger\n\t\tthis.init()\n\n\t\t// Emit event after restart is done\n\t\tthis.emit('restart')\n\t}\n\n\t// Stop animations and ScrollTriggers\n\tstop(target = null) {\n\t\tif (target) {\n\t\t\t// Stop animation and remove the ScrollTrigger for a specific target\n\t\t\tconst animationData = this.triggers.get(target)\n\t\t\tif (animationData) {\n\t\t\t\tanimationData.gsapAnimation.kill()\n\t\t\t\tthis.triggers.delete(target)\n\t\t\t}\n\t\t} else {\n\t\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\t\tthis.triggers.forEach(({ gsapAnimation }) => {\n\t\t\t\tgsapAnimation.kill()\n\t\t\t})\n\t\t\tthis.triggers.clear()\n\t\t}\n\n\t\t// Emit event after stop is done\n\t\tthis.emit('stop', target)\n\t}\n\n\t// Update animation for a specific target with new fromProperties and toProperties\n\tupdate(target, fromProperties, toProperties) {\n\t\tconst animationData = this.triggers.get(target)\n\n\t\tif (animationData) {\n\t\t\t// Stop the existing animation\n\t\t\tanimationData.gsapAnimation.kill()\n\n\t\t\t// Reinitialize the animation with updated properties\n\t\t\tconst gsapAnimation = this._gsap.fromTo(animationData.element, fromProperties, toProperties)\n\n\t\t\t// Create new ScrollTrigger for the updated animation\n\t\t\tconst trigger = this._ScrollTrigger.create({\n\t\t\t\tanimation: gsapAnimation,\n\t\t\t\ttrigger: this.getTrigger(animationData.element),\n\t\t\t\tstart: this.getStart(animationData.element),\n\t\t\t\tend: this.getEnd(animationData.element),\n\t\t\t\tscrub: this.getScrub(animationData.element),\n\t\t\t})\n\n\t\t\t// Save the updated animation data\n\t\t\tthis.triggers.set(target, {\n\t\t\t\t...animationData,\n\t\t\t\tfromProperties,\n\t\t\t\ttoProperties,\n\t\t\t\tgsapAnimation,\n\t\t\t\ttrigger,\n\t\t\t})\n\t\t}\n\t}\n\n\t// Destroy the OnscrollDetection instance\n\tdestroy() {\n\t\t// Stop all animations and clear the ScrollTrigger instances\n\t\tthis.stop()\n\t\tthis.triggers = null\n\t}\n}\n"],"names":["OnscrollDetection","constructor","options","gsap","ScrollTrigger","this","_gsap","_ScrollTrigger","elements","screen","triggers","Map","debug","scrollingClass","scrolledClass","stickyClass","stuckClass","eventHandlers","autoStart","undefined","init","register","utils","toArray","forEach","element","index","trigger","getTrigger","getScreen","matchMedia","fromProperties","getFromProperties","startAt","backgroundColor","immediateRender","toProperties","getToProperties","add","gsapAnimation","fromTo","set","scrollTrigger","debugMode","error","console","log","start","on","event","handler","push","emit","args","hasAttributes","hasAttribute","parentElement","document","querySelector","dataset","onscrollTrigger","onscrollScreen","animateFrom","getAnimateFrom","offset","getOffsetAndDistance","_extends","bottom","top","x","getDirection","y","animateTo","getAnimateTo","stickyProperties","getStickyProperties","isSticky","customEventName","getAttribute","progressEventName","dispatchCustomEvent","when","direction","window","dispatchEvent","CustomEvent","detail","target","getX","getY","ease","getStart","end","getEnd","invalidateOnRefresh","pin","pinSpacing","scrub","getScrub","markers","onUpdate","self","progress","toFixed","style","setProperty","dispatchProgressEvent","onToggle","isActive","onEnter","classList","onLeave","remove","onEnterBack","onLeaveBack","attrs","every","attr","JSON","parse","onscrollFrom","onscrollTo","getOffset","parseInt","onscrollOffset","onscrollDirection","getDistanceOrSpeed","distance","triggerHeight","offsetHeight","offsetValue","distanceValue","split","trim","endsWith","parseFloat","viewportHeight","innerHeight","scrollSpeed","onscrollSpeed","additionalDistance","includes","speed","percentage","map","triggerElement","autoDistance","Math","abs","onscrollDelay","stickyOffset","onscrollStart","positionElement","onscrollEnd","clientHeight","scrollDistance","speedMultiplier","speedViewportPercentage","speedValues","isNaN","hasSpeed","hasPreset","hasSticky","hasReverse","group","triggerStart","triggerEnd","auto","offsetBefore","offsetAfter","delay","preset","reverse","sticky","customEvent","onscrollCall","condition","message","warning","warn","groupEnd","fetch","elementOrIndex","Array","from","keys","value","key","refresh","restart","stop","getAll","kill","animationData","get","delete","clear","update","create","animation","destroy"],"mappings":"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"}